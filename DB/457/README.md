# 資料庫的：4 種交易屬性，5 種隔離級別，7 種傳播行為

<br>

---

<br>

## 4 種交易屬性（ACID）

<br>

* __原子性（atomicity）__ : 強調交易的不可分割。交易開始後所有操作，要麼全部做完，要麼全部不做，不可能停滯在中間環節。交易執行過程中出錯，會回滾到交易開始前的狀態，所有的操作就像沒有發生一樣。也就是說交易是一個不可分割的整體，就像化學中學過的原子，__是物質構成的基本單位__。

<br>

* __一致性（consistency）__ : 交易的執行的前後資料的完整性保持一致。交易開始前和結束後，資料庫的完整性約束沒有被破壞。例如A向B轉賬，不可能A扣了錢，B卻沒收到。

<br>

* __隔離性（isolation）__ : 一個交易執行的過程中,不應該受到其他交易的干擾。同一時間，只允許一個交易請求同一資料，不同的交易之間彼此沒有任何干擾。例如A正在從一張銀行卡中取錢，在A取錢的過程結束前，B不能向這張卡轉賬。

<br>

* __持久性（durability）__ : 交易一旦結束,資料就持久到資料庫。交易完成後，交易對資料庫的所有更新將被儲存到資料庫，不能回滾。

<br>
<br>
<br>
<br>


## 不考慮隔離性會引發的安全性問題

<br>

* __臟讀__ : 一個交易讀到了另一個交易的未提交的資料。交易A讀取了交易B更新的資料，然後B回滾操作，那麼A讀取到的資料是臟資料。

<br>

* __不可重複讀__ : 一個交易讀到了另一個交易已經提交的 update 的資料導致多次搜尋結果不一致。交易 A 多次讀取同一資料，交易 B 在交易A多次讀取的過程中，對資料作了更新並提交，導致交易A多次讀取同一資料時，結果 不一致。

<br>

* __虛幻讀__ : 一個交易讀到了另一個交易已經提交的 insert 的資料導致多次搜尋結果不一致。系統管理員A將資料庫中所有學生的成績從具體分數改為ABCDE等級，但是系統管理員B就在這個時候寫入了一條具體分數的紀錄，當系統管理員A改結束後發現還有一筆資料沒有改過來，就好像發生了幻覺一樣，這就叫幻讀。

<br>

---

<br>

tips:

不可重複讀的和幻讀很容易混淆，不可重複讀側重於修改，幻讀側重於新增或刪除。解決不可重複讀的問題只需鎖住滿足條件的行，解決幻讀需要鎖表

<br>

---

<br>
<br>
<br>
<br>

## 5 種隔離級別 (解決讀問題)

<br>

* DEFAULT : 這是一個 PlatfromTransactionManager 預設的隔離級別，使用資料庫預設的交易隔離級別。

    Mysql 預設 : 可重複讀

    Oracle 預設 : 已提交讀

<br>

* __未提交讀（read uncommited）__: 臟讀，不可重複讀，虛讀都有可能發生。
這是最低的交易隔離級別，它允許另外一個交易可以看到這個交易未提交的資料。

* __已提交讀（read commited）__ : 避免臟讀。但是不可重複讀和虛讀有可能發生。
這保證一個交易提交後才能被另外一個交易讀取。另外一個交易不能讀取該交易未提交的資料。

* __可重複讀（repeatable read)__ : 避免臟讀和不可重複讀.但是虛讀有可能發生。
這種交易隔離級別可以防止臟讀，不可重複讀。但是可能會出現幻象讀。它除了保證一個交易不能被另外一個交易讀取未提交的資料之外還避免了以下情況產生（不可重複讀）。

* __串列化（serializable）__ : 避免以上所有讀問題。
__這是花費最高代價但最可靠的交易隔離級別__。交易被處理為順序執行。除了防止臟讀，不可重複讀之外，還避免了幻象讀（避免三種）。

<br>

| 隔離級別 | 臟讀 | 不可重複讀 | 虛讀(幻讀) |
| :--: | :--: | :--: | :--: |
未提交讀|	可能|	可能|	可能|
已提交讀|	不可能|	可能|	可能|
可重複讀|	不可能|	不可能|	可能|
串列化|	不可能|	不可能|	不可能|

<br>
<br>
<br>
<br>

## 7 種傳播行為

<br>

1.保證在同一個交易中

|項|	行為|
|:-:|:-:|
|PROPAGATION_REQUIRED|	支援當前交易，如果不存在 就新建一個(預設)|
|PROPAGATION_SUPPORTS|	支援當前交易，如果不存在，就不使用交易|
|PROPAGATION_MANDATORY|	支援當前交易，如果不存在，丟擲異常|

<br>

2.保證不在同一個交易中
|項|	行為|
|:-:|:-:|
|PROPAGATION_REQUIRES_NEW|	如果有交易存在，掛起當前交易，建立一個新的交易|
|PROPAGATION_NOT_SUPPORTED|	以非交易方式執行，如果有交易存在，掛起當前交易|
|PROPAGATION_NEVER|	以非交易方式執行，如果有交易存在，丟擲異常|
|PROPAGATION_NESTED|	如果當前交易存在，則巢狀交易執行|

<br>
<br>
<br>
<br>

## Spring 中需要注意的點 

<br>

### @Transactional的使用事項

<br>

1. rollbackFor:

    預設情況下，如果在交易中丟擲了unchecked異常（繼承自 RuntimeException 的異常）或者 Error，則 Spring 將回滾交易；除此之外，Spring 不會回滾交易。
如果在交易中丟擲其他型別的異常，並期望 Spring 能夠回滾交易，可以指定 :

    ```java
    rollbackFor = {XException.class, YException.class}
    ```

<br>

2. @Transactional 只能應用到 public 方法才有效:

    衹有 `@Transactional` 註解應用到 public 方法，才能進行交易管理。這是因為在使用 Spring AOP 代理時，Spring 在呼叫在 __TransactionInterceptor__ 在目標方法執行前後進行攔截之前，__DynamicAdvisedInterceptor__（__CglibAopProxy__ 的內部類）的 `intercept` 方法或 __JdkDynamicAopProxy__ 的 `invoke` 方法會間接呼叫 __AbstractFallbackTransactionAttributeSource__（Spring 透過這個類取得 `@Transactional` 註解的交易屬性配置屬性訊息）的 `computeTransactionAttribute` 方法。這個方法會檢查目標方法的修飾字是不是 public，若不是 public，就不會取得 `@Transactional` 的屬性配置訊息，最終會造成不會用 __TransactionInterceptor__ 來攔截該目標方法進行交易管理。

<br>

3. Spring 的 AOP 的自呼叫問題:

    在 Spring 的 AOP 代理下，衹有目標方法由外部呼叫，目標方法才由 Spring 生成的代理物件來管理，這會造成自呼叫問題。若同一類中的其他沒有`@Transactional` 註解的方法內部呼叫有 `@Transactional` 註解的方法，有 `@Transactional` 註解的方法的交易被忽略，不會發生回滾。